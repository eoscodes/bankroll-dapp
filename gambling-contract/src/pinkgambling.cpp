#include <pinkgambling.hpp>
#include <bankrollmanagement.hpp>

static constexpr symbol CORE_SYMBOL = symbol("WAX", 8);

//Only needs to be called once after contract creation
ACTION pinkgambling::init() {
  require_auth(_self);
  statsTable.get_or_create(_self, statsStruct{});
}



/**
 * Action to start a cyclic roll
 * This action can be called by anyone as soon as the roll specific cycle time
 * has passed since the last result was gotten
 * 
 * Note: When no bets have been placed, instead of calling the bankroll contract,
 * a pseudo random number is generated. This is done so that gambling apps can still show
 * results generated by the blockchain, even when nobody has bet, while keeping the cpu
 * cost relatively low
 * 
 * @param roll_id - The id of the roll to start
 */
ACTION pinkgambling::startroll(uint64_t roll_id) {
  auto roll_itr = rollsTable.find(roll_id);
  check(roll_itr != rollsTable.end(),
  "no roll with this id exist");
  
  check(roll_itr->cycle_number != 0,
  "only cycle rolls can be started manually");
  
  check(roll_itr->last_cycle + microseconds(roll_itr->cycle_time * 1000000) <= current_time_point(),
  "not enough time has passed since the last result was received for this roll");
  
  rollBets_t betsTable(_self, roll_id);
  if (betsTable.begin() == betsTable.end()) {
    //No bets have been placed, generating pseudo random number for efficiency
    //Note: This is a really bad method to generate randomness, and can easily be predicted.
    uint128_t pseudo_random_seed = uint128_t{roll_id} << 64 | roll_itr->cycle_number;
    checksum256 random_value = sha256((char*)&pseudo_random_seed, 16);
    const auto random_array = random_value.get_array();
    //The first 128 bits of the random_value. The rest is not needed
    uint128_t random_number = random_array[0];
    uint32_t result = (random_number % roll_itr->max_result) + 1;
    rollsTable.modify(roll_itr, _self, [&](auto& r) {
      r.waiting_for_result = true;
    });
    handleResult(roll_id, result);
    
  } else {
    //At least one bet has been placed. Calling bankroll contract
    
    // Checks if the roll is within the bankroll contract's bankroll management
    // If not, all bets get reduced by the same factor so that the whole roll will be acceptable again
    // All bettors will immediately get the WAX that won't be bet sent back to them
    asset required_bankroll = calculateRollRequiredBankroll(roll_id);
    bankroll_stats_t bankrollStatsTable("pinkbankroll"_n, "pinkbankroll"_n.value);
    bankrollStatsStruct bankroll_stats = bankrollStatsTable.get();
    
    if (bankroll_stats.bankroll < required_bankroll) {
      double refund_factor = 1.01 - ((double)bankroll_stats.bankroll.amount / (double)required_bankroll.amount);  // 1.01 instead of 1.00 because of possible rounding errors
      std::string refund_factor_string = std::to_string(refund_factor * 100) + std::string("%");
      
      for (auto bet_itr = betsTable.begin(); bet_itr != betsTable.end(); bet_itr++) {
        uint64_t refund_amount = (uint64_t)((double)bet_itr->quantity.amount * refund_factor);
        asset refund_quantity = asset(refund_amount, CORE_SYMBOL);
        betsTable.modify(bet_itr, _self, [&](auto& b) {
          b.quantity -= refund_quantity;
        });
        
        action(
          permission_level{_self, "active"_n},
          "eosio.token"_n,
          "transfer"_n,
          std::make_tuple(_self, bet_itr->bettor, refund_quantity, std::string("The bets in the cycle were to high for the bankroll. Therefore ") + refund_factor_string + std::string(" of your bet were refunded. The rest will be bet normally. Note that this is done before the result gets computed."))
        ).send();
      }
      
      action(
        permission_level{_self, "active"_n},
        _self,
        "logreduction"_n,
        std::make_tuple(roll_id, roll_itr->cycle_number, refund_factor)
      ).send();
    }
    
    sendRoll(roll_id);
  }
}




/**
 * This is called whenever there is a eosio.token transfer involving pinkbankroll as either sender or recipient
 * The memo is parsed and private functions are then called with the parsed input
 * 
 * @param from - The account name that sent the transfer
 * @param to - The account name that receives the transfer
 * @param quantity - The quantity of tokens sent. This could theoretically be something else than WAX, therefore has to be checked
 * @param memo - A string of up to 256 characers, used to identify what this transaction is meant for
 */

void pinkgambling::receivetransfer(name from, name to, asset quantity, std::string memo) {
  if (to != _self) {
    return;
  }
  check(quantity.symbol == CORE_SYMBOL,
  "quantity must be in WAX");
  
  if (memo.find("#createcycle ") == 0) {
    check(quantity.amount == 1000000000,
    "you must send exactly 10 WAX to create a new cycle");
    
    std::string substrings[3];
    int64_t last_whitespace = memo.find(" ");
    for (int i = 0; i < 2; i++) {
      int64_t next_whitespace = memo.find(" ", last_whitespace + 1);
      check(next_whitespace != std::string::npos,
      "memo has an invalid input format");
      substrings[i] = memo.substr(last_whitespace + 1, next_whitespace - last_whitespace - 1);
      last_whitespace = next_whitespace;
    }
    substrings[2] = memo.substr(last_whitespace + 1);
    
    uint32_t parsed_max_result = std::strtoull(substrings[0].c_str(), 0, 10);
    uint32_t parsed_cycle_time = std::strtoull(substrings[1].c_str(), 0, 10);
    name parsed_rake_recipient = name(substrings[2]);
    
    createCycle(parsed_max_result, parsed_rake_recipient, parsed_cycle_time);
    
    
  } else if (memo.find("#bet ") == 0) {
    std::string substrings[6];
    int64_t last_whitespace = memo.find(" ");
    
    for (int i = 0; i < 5; i++) {
      int64_t next_whitespace = memo.find(" ", last_whitespace + 1);
      check(next_whitespace != std::string::npos,
      "memo has an invalid input format");
      substrings[i] = memo.substr(last_whitespace + 1, next_whitespace - last_whitespace - 1);
      last_whitespace = next_whitespace;
    }
    substrings[5] = memo.substr(last_whitespace + 1);
    
    uint32_t parsed_multiplier = std::strtoull(substrings[0].c_str(), 0, 10);
    uint32_t parsed_lower_bound = std::strtoull(substrings[1].c_str(), 0, 10);
    uint32_t parsed_upper_bound = std::strtoull(substrings[2].c_str(), 0, 10);
    name parsed_rake_recipient = name(substrings[3]);
    uint64_t parsed_identifier = std::strtoull(substrings[4].c_str(), 0, 16);
    uint64_t parsed_random_seed = std::strtoull(substrings[5].c_str(), 0, 16);
    
    quickBet(quantity, from, parsed_multiplier, parsed_lower_bound, parsed_upper_bound, parsed_rake_recipient, parsed_identifier, parsed_random_seed);
    
    
  } else if (memo.find("#join ") == 0) {
    std::string substrings[5];
    int64_t last_whitespace = memo.find(" ");
    
    for (int i = 0; i < 4; i++) {
      int64_t next_whitespace = memo.find(" ", last_whitespace + 1);
      check(next_whitespace != std::string::npos,
      "memo has an invalid input format");
      substrings[i] = memo.substr(last_whitespace + 1, next_whitespace - last_whitespace - 1);
      last_whitespace = next_whitespace;
    }
    substrings[4] = memo.substr(last_whitespace + 1);
    
    uint32_t parsed_roll_id = std::strtoull(substrings[0].c_str(), 0, 10);
    uint32_t parsed_multiplier = std::strtoull(substrings[1].c_str(), 0, 10);
    uint32_t parsed_lower_bound = std::strtoull(substrings[2].c_str(), 0, 10);
    uint32_t parsed_upper_bound = std::strtoull(substrings[3].c_str(), 0, 10);
    uint64_t parsed_random_seed = std::strtoull(substrings[4].c_str(), 0, 16);
    
    addBet(quantity, parsed_roll_id, from, parsed_multiplier, parsed_lower_bound, parsed_upper_bound, parsed_random_seed);
    
  } else {
    check(false, "invalid memo");
  }
}




/**
 * This is called by the bankroll contract when there is a result for one of the submitted rolls available
 * 
 * @param creator - The creator of the roll, should always be this contract
 * @param creator_id - The creator id submitted when sending the roll data to the bankroll contract. Equal to the roll_id
 * @param result - The result of the bet
 */
void pinkgambling::receivenotifyresult(name creator, uint64_t creator_id, uint32_t result) {
  check(creator == _self,
  "this result is not meant for this account");
  
  handleResult(creator_id, result);
}




/**
 * Private function to create a new cycle that has already been paid for
 * 
 * @param max_result - The max result that can be rollled
 * @param rake_recipient - The account name that will receive the rake for this cycle
 * @param cycle_time - The time in seconds that each cycle should last for
 */
void pinkgambling::createCycle(uint32_t max_result, name rake_recipient, uint32_t cycle_time) {
  check(cycle_time >= 10,
  "the cycle time must be at last 10 seconds");
  //available_primary_key can't be used, because finished rolls are deleted from the table
  statsStruct stats = statsTable.get();
  uint64_t roll_id = stats.current_roll_id++;
  statsTable.set(stats, _self);
  
  rollsTable.emplace(_self, [&](rollStruct &r) {
    r.roll_id = roll_id;
    r.max_result = max_result;
    r.rake_recipient = rake_recipient;
    r.waiting_for_result = false;
    r.identifier = 0;
    r.cycle_number = 1;
    r.last_cycle = current_time_point();
    r.last_player_joined = current_time_point();
    r.cycle_time = cycle_time;
  });
  
  action(
    permission_level{_self, "active"_n},
    "eosio.token"_n,
    "transfer"_n,
    std::make_tuple(_self, "pinknetworkx"_n, asset(1000000000, CORE_SYMBOL), std::string("payment for new cycle"))
  ).send();
}




/**
 * Private function to create and send a bet within a single transaction. max_result is always 10000
 * 
 * @param quantity - The amount of WAX to be bet
 * @param bettor - The account name of the bettor
 * @param multiplier - The multiplier of the bet x1000 (multiplier 2000 => 2x payout)
 * @param lower_bound - The lower bound of the range to bet on
 * @param upper_bound - The upper bound of the range to bet on
 * @param rake_recipient - The account name to receive the rake for this bet
 * @param identifier - An identifier used for tracking this bet, but generally not used for the smart contact logic
 * @param client_seed - A seed that will be used in the bankroll contract. Should be random to avoid possible collisions in the RNG oracle
 */
void pinkgambling::quickBet(asset quantity, name bettor, uint32_t multiplier, uint32_t lower_bound, uint32_t upper_bound, name rake_recipient, uint64_t identifier, uint64_t random_seed)  {
  //available_primary_key can't be used, because finished rolls are deleted from the table
  statsStruct stats = statsTable.get();
  uint64_t roll_id = stats.current_roll_id++;
  statsTable.set(stats, _self);
  
  rollsTable.emplace(_self, [&](rollStruct &r) {
    r.roll_id = roll_id;
    r.max_result = 10000;
    r.rake_recipient = rake_recipient;
    r.waiting_for_result = false;
    r.identifier = identifier;
    r.cycle_number = 0;
    r.last_cycle = eosio::time_point(microseconds(0));
    r.last_player_joined = eosio::time_point(microseconds(0));
    r.cycle_time = 0;
  });
  
  addBet(quantity, roll_id, bettor, multiplier, lower_bound, upper_bound, random_seed);
  sendRoll(roll_id);
}




/**
 * Private function to add bets to a roll.
 * Checks for validity of the inputs, as well as checking if the bet is acceptable
 * for the bankroll contract.
 * 
 * @param quantity - The amount of WAX to be bet
 * @param bettor - The account name of the bettor
 * @param multiplier - The multiplier of the bet x1000 (multiplier 2000 => 2x payout)
 * @param lower_bound - The lower bound of the range to bet on
 * @param upper_bound - The upper bound of the range to bet on
 */
void pinkgambling::addBet(asset quantity, uint64_t roll_id, name bettor, uint32_t multiplier, uint32_t lower_bound, uint32_t upper_bound, uint64_t random_seed) {
  auto roll_itr = rollsTable.find(roll_id);
  check(roll_itr != rollsTable.end(),
  "no roll with this id exist");
  check(!roll_itr->waiting_for_result,
  "cant join while the roll is waiting for a result");
  rollsTable.modify(roll_itr, _self, [&](auto& r) {
    r.last_player_joined = current_time_point();
  });
  
  
  check(lower_bound >= 1,
  "lower_bound needs to be at least 1");
  check(lower_bound <= upper_bound,
  "lower_bound can't be greater than upper_bound");
  check(upper_bound <= roll_itr->max_result,
  "upper_bound can't be greater than the max_result of the roll");
  
  check(multiplier > 1000,
  "the multiplier has to be greater than 1000 (greater than 1x)");
  
  double odds = (double)(upper_bound - lower_bound + 1) / (double)roll_itr->max_result;
  check (odds >= 0.005,
  "the odds cant be smaller than 0.005");
  double ev = odds * multiplier / 1000.0;
  check(ev <= 0.99,
  "the bet cant have an EV greater than 0.99 * quantity");
  
  rollBets_t betsTable(_self, roll_id);
  uint64_t bet_id = betsTable.available_primary_key();
  if (bet_id >= 10) {
    check(quantity.amount >= 100000000,
    "The 10th bet and higher need to be at least 1 WAX as a spam protection");
  };
  if (bet_id >= 100) {
    check(quantity.amount >= 1000000000,
    "The 100th bet and higher need to be at least 10 WAX as a spam protection");
  }
  betsTable.emplace(_self, [&](betStruct &b) {
    b.bet_id = bet_id;
    b.bettor = bettor;
    b.quantity = quantity;
    b.lower_bound = lower_bound;
    b.upper_bound = upper_bound;
    b.multiplier = multiplier;
    b.random_seed = random_seed;
  });
  
  asset required_bankroll = calculateRollRequiredBankroll(roll_id);
  bankroll_stats_t bankrollStatsTable("pinkbankroll"_n, "pinkbankroll"_n.value);
  bankrollStatsStruct bankroll_stats = bankrollStatsTable.get();
  
  // The maxbet for the gambling contract is 95% of the maxbet of the bankroll contract
  // This is to make a sitation in which the bankroll would shrink so low that the original bet wouldn't be accepted anymore
  // less likely and harder to provoke
  check(bankroll_stats.bankroll.amount * 0.95 >= required_bankroll.amount,
  "the current bankroll is too small to accept this bet");
  
  action(
    permission_level{_self, "active"_n},
    _self,
    "logbet"_n,
    std::make_tuple(roll_id, roll_itr->cycle_number, bet_id, bettor, quantity, lower_bound, upper_bound, multiplier, random_seed)
  ).send();
}




/**
 * Private function that first transmits all the required data of a roll to the bankroll cotnract
 * and then sends the WAX to start the roll
 * 
 * @param roll_id - The id of the roll to send
 */
void pinkgambling::sendRoll(uint64_t roll_id) {
  auto roll_itr = rollsTable.find(roll_id);
  check(roll_itr != rollsTable.end(),
  "the roll id doesn't exist");
  
  check(!roll_itr->waiting_for_result,
  "the roll has already been sent to the bankroll cotnract");
  
  rollsTable.modify(roll_itr, _self, [&](auto& r) {
    r.waiting_for_result = true;
  });
  
  
  action(
    permission_level{_self, "active"_n},
    "pinkbankroll"_n,
    "announceroll"_n,
    std::make_tuple(_self, roll_id, roll_itr->max_result, roll_itr->rake_recipient)
  ).send();
  
  asset total_bet = asset(0, CORE_SYMBOL);
  rollBets_t betsTable(_self, roll_id);
  for (auto bet_itr = betsTable.begin(); bet_itr != betsTable.end(); bet_itr++) {
    total_bet += bet_itr->quantity;
    action(
    permission_level{_self, "active"_n},
      "pinkbankroll"_n,
      "announcebet"_n,
      std::make_tuple(_self, roll_id, bet_itr->bettor, bet_itr->quantity, bet_itr->lower_bound, bet_itr->upper_bound, bet_itr->multiplier, bet_itr->random_seed)
    ).send();
  }
  
  action(
    permission_level{_self, "active"_n},
    "eosio.token"_n,
    "transfer"_n,
    std::make_tuple(_self, "pinkbankroll"_n, total_bet, std::string("startroll ") + std::to_string(roll_id))
  ).send();
  
}




/**
 * Private function to handle receiving a new result.
 * For non-cycle rolls, it deletes the table entries, for cyclic rolls,
 * it resets the bets and updates the roll table entry
 * 
 * @param roll_id - The id of the roll that this result is for
 * @param result - The result number
 */
void pinkgambling::handleResult(uint64_t roll_id, uint32_t result) {
  auto roll_itr = rollsTable.find(roll_id);
  check(roll_itr != rollsTable.end(),
  "no roll with this id exist");
  check(roll_itr->waiting_for_result,
  "the roll isn't waiting for a result");
  
  action(
    permission_level{_self, "active"_n},
    _self,
    "logresult"_n,
    std::make_tuple(roll_id, roll_itr->cycle_number, roll_itr->max_result, roll_itr->rake_recipient, result, roll_itr->identifier, roll_itr->cycle_time)
  ).send();
  
  //Removing all bet table entries
  rollBets_t betsTable(_self, roll_id);
  auto bet_itr = betsTable.begin();
  while(bet_itr != betsTable.end()) {
    //erase returns iterator poiting to next entry
    bet_itr = betsTable.erase(bet_itr);
  }
  
  if (roll_itr->cycle_number == 0) {
    //Non-cycle roll
    rollsTable.erase(roll_itr);
    
  } else {
    //Cycle roll
    rollsTable.modify(roll_itr, _self, [&](auto& r) {
      r.cycle_number += 1;
      r.waiting_for_result = false;
      r.last_cycle = current_time_point();
    });
  }
}


/**
 * Calculates the required bankroll of a roll dependant on the current bets of this roll
 * 
 * @param roll_id - The id of the roll to calculate the required bankroll for
 */
asset pinkgambling::calculateRollRequiredBankroll(uint64_t roll_id) {
  auto roll_itr = rollsTable.find(roll_id);
  check(roll_itr != rollsTable.end(),
  "no roll with this id exist");
  rollBets_t betsTable(_self, roll_id);
  
  ChainedRange firstRange = ChainedRange(1, roll_itr->max_result, 0);
  asset total_bets_collected = asset(0, CORE_SYMBOL);  // = total_quantity_bet - (rake + fees)
  
  for (auto bet_itr = betsTable.begin(); bet_itr != betsTable.end(); bet_itr++) {
    double ev = (double)bet_itr->multiplier / 1000.0 * (double)(bet_itr->upper_bound - bet_itr->lower_bound + 1) / (double)roll_itr->max_result;
    total_bets_collected.amount += (int64_t)((double)bet_itr->quantity.amount * (ev + 0.007));
    
    uint64_t payout = bet_itr->quantity.amount * bet_itr->multiplier / 1000;
    firstRange.insertBet(bet_itr->lower_bound, bet_itr->upper_bound, payout);
  }
  
  bankroll_stats_t bankrollStatsTable("pinkbankroll"_n, "pinkbankroll"_n.value);
  asset required_bankroll = getRequiredBankroll(firstRange, total_bets_collected.amount, roll_itr->max_result);
  return required_bankroll;
}


//Only for external logging

ACTION pinkgambling::logbet(uint64_t roll_id, uint64_t cycle_number, uint64_t bet_id, name bettor, asset quantity, uint32_t lower_bound, uint32_t upper_bound, uint32_t multiplier, uint64_t client_seed) {
  require_auth(_self);
}

ACTION pinkgambling::logresult(uint64_t roll_id, uint64_t cycle_number, uint32_t max_result, name rake_recipient, uint32_t roll_result, uint64_t identifier, uint32_t cycle_time) {
  require_auth(_self);
}

ACTION pinkgambling::logreduction(uint64_t roll_id, uint64_t cycle_number, double reduction) {
  require_auth(_self);
}